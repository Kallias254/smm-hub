# The Creative Engine: Specification

This module is responsible for turning "raw, ugly inputs" into "polished, branded assets" without human intervention.

## 1. Architecture: The Job Queue

We will utilize **Payload v3 Native Jobs**. Heavy processing (video encoding, image generation) **MUST NOT** happen in the HTTP request loop.

**Flow:**
1.  User uploads image.
2.  `afterChange` hook detects new media.
3.  Hook dispatches a `generate-branded-assets` job to the Payload Queue.
4.  Worker picks up job, runs Satori/FFmpeg, and updates the `Media` record with the new URL.

## 2. Image Generation (Satori)

**Stack:** `@vercel/satori`, `satori-html`, `react`.

### Concept: Dynamic Templates
We will store "Templates" as React components.
*   **Default:** "Gold Standard" (Real Estate).
*   **Customization:** Templates accept `primaryColor`, `agencyLogo`, and dynamic text props.
*   **Designer-Friendly:** Supports "Background Mode" where a designer provides a static base (JPG) and Satori only overlays the data (Price/Title) in safe zones.

**The Process:**
1.  **Input:**
    *   Background Image (User Upload OR Designer Base)
    *   Price Text (e.g., "KES 5,000")
    *   Badge Type (e.g., "Verified", "Sold", "Hot")
2.  **Composition:**
    *   Satori renders a React component to SVG.
    *   **Crucial Technique:** Background images are rendered as absolute-positioned `<img>` tags (not CSS backgrounds) for stability.
    *   Component includes Tailwind-like styles for glassmorphism, gold borders, and text overlays.
    *   `resvg-js` / `sharp` converts SVG to high-quality PNG.
3.  **Optimization:**
    *   Output tailored to 1080x1350 (Instagram Portrait) or 1080x1080 (Square).

## 3. Video Production (FFmpeg)

**Stack:** `fluent-ffmpeg`, `node-child-process`.

**The Recipe (The "15-Second Spot"):**
1.  **Intro Card (1.5s):** Generated by Satori. "Just Listed" / Brand Logo.
2.  **Main Content (12s):**
    *   Ken Burns effect (slow pan/zoom) on the static house image.
    *   OR: Concatenation of uploaded video clips.
3.  **Outro Card (1.5s):** Generated by Satori. "Call Now: 0722..." + Logo.
4.  **Audio Bed:**
    *   Library of royalty-free MP3s stored in Payload.
    *   Auto-ducking: If user uploaded a voiceover, background music volume drops by 15dB.

**Code Pattern:**
The `generateBrandedVideoTask` handles the orchestration, using a temporary directory for file manipulation before uploading the final result to the Media collection.

## 4. "Showroom Pro" (Background Removal)

**Stack:** `@imgly/background-removal-node` (runs locally, no API cost) or `rembg` (Python sidecar).

**Flow:**
1.  Raw furniture photo enters.
2.  Background removed.
3.  Resulting transparent PNG is layered over a pre-selected "Luxury Apartment" background image via `sharp` or `satori`.

## 5. Headless Creative Generation (V2)

The V1 Creative Engine (Satori/FFmpeg) is powerful but requires that all creative logic be coded directly within the application. The V2 engine introduces a "headless" architecture, allowing for far greater creative flexibility without requiring backend code changes.

This model decouples the **Creative Design** from the **Content Injection**.

-   **Creative Design:** Happens outside the system in professional design tools (e.g., Adobe After Effects, Remotion).
-   **Content Injection:** Happens inside the SMM Hub, where the system programmatically inserts a client's specific data into the pre-designed template.

### 5.1. Template Registration

Admins will have access to a "Creative Templates" collection where they can register new templates. A template record will consist of:

1.  **Template Name:** A human-readable name (e.g., "Elegant Real Estate Showcase Video").
2.  **Niche Association:** The niche this template is designed for (e.g., 'Real Estate', 'Restaurant').
3.  **Template Asset:** The uploaded template file itself (e.g., a Lottie JSON file, a Remotion bundle).
4.  **Data Mapping Schema:** A JSON object defining the available placeholders in the template and what data they map to.

**Example Data Mapping Schema:**

```json
{
  "placeholders": [
    { "id": "price_text", "label": "Property Price", "mapsTo": "property.price" },
    { "id": "headline_text", "label": "Main Headline", "mapsTo": "post.title" },
    { "id": "agent_name_text", "label": "Agent's Name", "mapsTo": "agent.name" },
    { "id": "main_image_1", "label": "Primary Image", "mapsTo": "media.tag.exterior" },
    { "id": "secondary_image_1", "label": "Kitchen Image", "mapsTo": "media.tag.kitchen" }
  ]
}
```

### 5.2. The Role of FFmpeg

`ffmpeg` remains the core rendering workhorse, but its role shifts from direct composition to being a "final assembly" tool.

**Primary `ffmpeg` Tasks:**
1.  **Image/Video Substitution:** Replacing placeholder layers in a template with the actual media assets from a `Post`. For example, swapping `placeholder_kitchen.png` with the user's uploaded and tagged kitchen photo.
2.  **Text Overlay:** Using the `drawtext` filter to burn in dynamic text (price, headlines) based on the template's mapping schema.
3.  **Concatenation & Stitching:** Assembling different rendered scenes (e.g., an intro, a main body, an outro) into a single video file.
4.  **Audio Mixing:** Overlaying a licensed audio track and ducking it for any voiceover content.

This headless model means we can introduce new, complex video designs for any niche simply by uploading a new template, without ever deploying new backend code.
